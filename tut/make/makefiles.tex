\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage{amsthm}
\usepackage{listings}

\lstdefinestyle{makefile}
{
    numberblanklines=false,
    language=make,
    tabsize=4,
    keywordstyle=\color{red},
    identifierstyle= %plain identifiers for make
}

\title{Algorithm Analysis Textbook Notes}
\author{Chris Wozniak}

\begin{document}
\begin{center}
	\Large\textbf{GNU Makefiles}
\end{center}
	You require a file called ``makefile" to tell make what to do. Most often, this will tell make how to compile and link
	a program.
	\section*{Format}
		The basic makefile consists of a set of \textbf{Rules} which have the format:
		\begin{itemize}
			\item The \textbf{target} is usually the name of a file that is generated by a program. It can 
				also be the name of an action to be carried out, and are considered \textbf{phony targets} There can
				also be many targets, separated by spaces if required.
			\item A \textbf{prerequisite} is a file that is used as input to create the target. A target may have
				many dependencies.
			\item A \textbf{recipe} is an action that make carries out. It may have more than one command on each line
				or inline. \textbf{NOTE:} All recipe statements require a \textbf{hard tab}.
		\end{itemize}
		As well, \# characters are used to denote inline comments, and use the \textbackslash command to split
		long lines up.
\begin{lstlisting}[language=make]
		target: prerequisites
		[tab] recipe
		[tab] ...
\end{lstlisting}
		Thus a Rule explains how and when to remake certain files which are the targets of a particular rule.
	\section*{A Simple Makefile}
		Say we had a program which had a self-created library my\_math.c associated with it. We also know that we
		want our program to be named ``math\_work.o" we could organize our makefile as follows:
	\begin{lstlisting}[language=make]
		math_work.o: main.o my_math.o
			gcc main.o my_math.o
		main.o: main.c
			gcc -c main.c
		my_math.o: my_math.c
			gcc -c my_math.c
		clean:
			rm *.o
	\end{lstlisting}
		By default, \textit{make} starts with the first target (except targets whose name startes with a period: ``.hello") this is
		called the \textbf{default goal}. Since we want to make a program ``math\_work.o" we merely run the command 
		\textit{make} which will start to process the first rule. Before the rule can be completed, it must process the rules
		that this rule depends on. By setting things up this way, only updated files will be recompiled and linked, saving us time 
		for larger programs.
	\section*{Variables}
		Variables allow a text string to be defined once, and substituted in multiple places later. This reduces redundancy in our
		code, making it less error prone. It is standard practice to have a list of object names often called \textit{objects,
		OBJECTS, objs, or obj} at the top of our file.\\

		We \textbf{use} our variables by placing them inside a $\$(objects)$ set of brackets, and a \$ sign.
	\begin{lstlisting}[language=make]
		objects = main.o my_math.o
		math_work.o: $(objects)
			gcc $(objects)
		main.o: main.c
			gcc -c main.c
		my_math.o: my_math.c
			gcc -c my_math.c
		clean:
			rm math_work.o $(objects)
	\end{lstlisting}
	There are \textbf{MANY} other features of make, such as rewriting, or importing other makefiles, static pattern rules, 
	overriding variables, different targets being generated based on different additions added to make. See this link for
	the complete manual:\\ \url{http://www.gnu.org/software/make/manual/make.html#Top} if you require specifics.

\end{document}
